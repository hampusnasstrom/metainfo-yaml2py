'''
metainfoyaml2py module
'''

import sys
import os
import json
import yaml
import autopep8
import autoflake

from pkg_resources import resource_filename

resource_path = resource_filename(__name__, 'resources')


def read_yaml(path: str) -> dict:
    '''Help function for reading YAML file into dict using pyyaml.

    Args:
        path (str): The path to the YAML file including the `.yaml` extension.

    Returns:
        dict: Dictionary representation of the YAML file.
    '''
    with open(path, 'r', encoding="utf8") as file:
        return yaml.safe_load(file)


def parse_quantity(quantity_name: str, quantity_dict: dict) -> str:
    '''Parse the content of metainfo quantity into Python instance.

    Args:
        quantity_name (str): The name of the quantity.
        quantity_dict (dict): A dictionary representation for the YAML content for the quantity to
        be parsed.

    Returns:
        str: The instantiated quantity variable of the parsed quantity as python code.

    Raises:
        ValueError: If the YAML file is not a valid NOMAD metainfo schema.
    '''
    code = ""
    code += f"{quantity_name} = Quantity("
    try:
        quantity_type = quantity_dict['type']
    except KeyError as exc:
        raise ValueError(f'No "type" key found in quantity {quantity_name}.') from exc
    if isinstance(quantity_type, dict):
        if quantity_type['type_kind'] == 'Enum':
            quantity_type = f"MEnum({quantity_type['type_data']})"
        else:
            raise ValueError('Unknown type_kind in quantity.')
    elif quantity_type == 'string':
        quantity_type = 'str'
    elif quantity_type == 'integer':
        quantity_type = 'int'
    elif quantity_type == 'boolean':
        quantity_type = 'bool'
    code += "type=" + quantity_type
    if "description" in quantity_dict:
        code += ", description=" + "'" + \
            quantity_dict['description'].replace('\n', '\\n') + "'"
    if "shape" in quantity_dict:
        code += f", shape={quantity_dict['shape']}"
    if "m_annotations" in quantity_dict:
        annotation_dict = quantity_dict["m_annotations"]
        if "eln" in annotation_dict:
            code += ", a_eln=" + json.dumps(annotation_dict["eln"])
    code += ")\n"
    return code


def parse_section(section_name: str, section_dict: dict) -> str:
    '''Parse the content of a metainfo section into a Python class.

    Args:
        section_name (str): The name of the section.
        section_dict (dict): A dictionary representation of the YAML content for the section to be
        parsed.

    Returns:
        str: The class defintion of the parsed section as python code.
    '''
    code = ""
    description = section_dict.get(
        'description', 'Class autogenerated from yaml schema.')
    if description[-1] == '\n':
        description = description[:-1]
    code += f"class {section_name}:\n    '''{description}'''\n    pass\n"
    quantities = section_dict.get('quantities', {})
    for quantity in quantities:
        code += "    " + \
            parse_quantity(quantity_name=quantity,
                           quantity_dict=quantities[quantity]) + '\n'
    return code


def yaml2py(yaml_path: str, output_dir: str = '') -> None:
    '''Function for parsing a NOMAD metainfo YAML schema into a python file of class definitions.

    Args:
        yaml_path (str): The path to the YAML file including the `.yaml` extension
        output_dir (str, optional): The output directory where the `__init__.py` file is saved.
        Defaults to ''.

    Raises:
        ValueError: If the YAML file is not a valid NOMAD metainfo schema.
    '''
    # Read the YAML file into dict and get the definitions key
    try:
        yaml_dict = read_yaml(yaml_path).get('definitions')
    except KeyError as exc:
        raise ValueError('No "definitions" key found in YAML file.') from exc
    # Get the standard contents from the 'standard_file_content.yaml' file
    content = read_yaml(os.path.join(
        resource_path, 'standard_file_content.yaml'))
    # Create output file with context manager
    with open(os.path.join(output_dir, '__init__.py'), 'w', encoding="utf8") as file:
        # Write the file content to string variable `code`
        code = content['header'] + '\n'
        code += content['imports'] + '\n'
        # Get the package name, defaults to YAML file name (without
        # .schema.archive.yaml)
        file_name = os.path.basename(yaml_path).split("/")[-1]
        package_name = yaml_dict.get('name', file_name.split('.')[0])
        code += content['package_name'] % package_name + '\n'
        sections = yaml_dict.get('sections', {})
        for section in sections:
            code += parse_section(section_name=section,
                                  section_dict=sections[section]) + '\n'
        code += content['footer'] + '\n'
        # Clean up the code using autopep8 and autoflake
        flake8_cleaned_code = autoflake.fix_code(
            code, remove_all_unused_imports=True)
        cleaned_code = autopep8.fix_code(
            flake8_cleaned_code, options={'aggressive': 2})
        # write the code to file
        file.write(cleaned_code)
        # file.write(code)


def main() -> None:
    '''Main function for running the metainfo YAML to Python class definition parser.
    '''
    if len(sys.argv) < 2 or len(sys.argv) > 3:
        sys.exit(
            "Please provide path to YAML file and optionally path to output directory.")
    yaml2py(*sys.argv[1:3])


if __name__ == "__main__":
    main()
